<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  
  
  <link rel="shortcut icon" href="../../img/favicon.ico">
  <title>JSON Web Token Cheat Sheet for Java - OWASP Cheat Sheet Series</title>
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Lato:400,700|Roboto+Slab:400,700|Inconsolata:400,700" />

  <link rel="stylesheet" href="../../css/theme.css" />
  <link rel="stylesheet" href="../../css/theme_extra.css" />
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css" />
  
  <script>
    // Current page data
    var mkdocs_page_name = "JSON Web Token Cheat Sheet for Java";
    var mkdocs_page_input_path = "cheatsheets/JSON_Web_Token_Cheat_Sheet_for_Java.md";
    var mkdocs_page_url = null;
  </script>
  
  <script src="../../js/jquery-2.1.1.min.js" defer></script>
  <script src="../../js/modernizr-2.8.3.min.js" defer></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
  <script>hljs.initHighlightingOnLoad();</script> 
  
</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side stickynav">
    <div class="wy-side-scroll">
      <div class="wy-side-nav-search">
        <a href="../.." class="icon icon-home"> OWASP Cheat Sheet Series</a>
        <div role="search">
  <form id ="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" title="Type search term here" />
  </form>
</div>
      </div>

      <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
                <ul>
                    <li class="toctree-l1"><a class="reference internal" href="../..">Home</a>
                    </li>
                </ul>
                <ul>
                    <li class="toctree-l1"><a class="reference internal" href="../../IndexASVS/">Index ASVS</a>
                    </li>
                </ul>
                <ul>
                    <li class="toctree-l1"><a class="reference internal" href="../../IndexProactiveControls/">Index Proactive Controls</a>
                    </li>
                </ul>
                <ul>
                    <li class="toctree-l1"><a class="reference internal" href="../../glossary/">Index Alphabetical</a>
                    </li>
                </ul>
                <p class="caption"><span class="caption-text">Cheatsheets</span></p>
                <ul class="current">
                    <li class="toctree-l1"><a class="reference internal" href="../AJAX_Security_Cheat_Sheet/">AJAX Security Cheat Sheet</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../Abuse_Case_Cheat_Sheet/">Abuse Case Cheat Sheet</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../Access_Control_Cheat_Sheet/">Access Control Cheat Sheet</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../Attack_Surface_Analysis_Cheat_Sheet/">Attack Surface Analysis Cheat Sheet</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../Authentication_Cheat_Sheet/">Authentication Cheat Sheet</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../Authorization_Testing_Automation/">Authorization Testing Automation</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../Bean_Validation_Cheat_Sheet/">Bean Validation Cheat Sheet</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../C-Based_Toolchain_Hardening/">C-Based Toolchain Hardening</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../C-Based_Toolchain_Hardening_Cheat_Sheet/">C-Based Toolchain Hardening Cheat Sheet</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../Choosing_and_Using_Security_Questions_Cheat_Sheet/">Choosing and Using Security Questions Cheat Sheet</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../Clickjacking_Defense_Cheat_Sheet/">Clickjacking Defense Cheat Sheet</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../Content_Security_Policy_Cheat_Sheet/">Content Security Policy Cheat Sheet</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../Credential_Stuffing_Prevention_Cheat_Sheet/">Credential Stuffing Prevention Cheat Sheet</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../Cross-Site_Request_Forgery_Prevention_Cheat_Sheet/">Cross-Site Request Forgery Prevention Cheat Sheet</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../Cross_Site_Scripting_Prevention_Cheat_Sheet/">Cross Site Scripting Prevention Cheat Sheet</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../Cryptographic_Storage_Cheat_Sheet/">Cryptographic Storage Cheat Sheet</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../DOM_based_XSS_Prevention_Cheat_Sheet/">DOM based XSS Prevention Cheat Sheet</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../Database_Security_Cheat_Sheet/">Database Security Cheat Sheet</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../Denial_of_Service_Cheat_Sheet/">Denial of Service Cheat Sheet</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../Deserialization_Cheat_Sheet/">Deserialization Cheat Sheet</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../Docker_Security_Cheat_Sheet/">Docker Security Cheat Sheet</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../DotNet_Security_Cheat_Sheet/">DotNet Security Cheat Sheet</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../Error_Handling_Cheat_Sheet/">Error Handling Cheat Sheet</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../File_Upload_Cheat_Sheet/">File Upload Cheat Sheet</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../Forgot_Password_Cheat_Sheet/">Forgot Password Cheat Sheet</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../HTML5_Security_Cheat_Sheet/">HTML5 Security Cheat Sheet</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../HTTP_Strict_Transport_Security_Cheat_Sheet/">HTTP Strict Transport Security Cheat Sheet</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../Injection_Prevention_Cheat_Sheet/">Injection Prevention Cheat Sheet</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../Injection_Prevention_Cheat_Sheet_in_Java/">Injection Prevention Cheat Sheet in Java</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../Input_Validation_Cheat_Sheet/">Input Validation Cheat Sheet</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../Insecure_Direct_Object_Reference_Prevention_Cheat_Sheet/">Insecure Direct Object Reference Prevention Cheat Sheet</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../JAAS_Cheat_Sheet/">JAAS Cheat Sheet</a>
                    </li>
                    <li class="toctree-l1 current"><a class="reference internal current" href="./">JSON Web Token Cheat Sheet for Java</a>
    <ul class="current">
    </ul>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../Key_Management_Cheat_Sheet/">Key Management Cheat Sheet</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../LDAP_Injection_Prevention_Cheat_Sheet/">LDAP Injection Prevention Cheat Sheet</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../Logging_Cheat_Sheet/">Logging Cheat Sheet</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../Mass_Assignment_Cheat_Sheet/">Mass Assignment Cheat Sheet</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../Microservices_based_Security_Arch_Doc_Cheat_Sheet/">Microservices based Security Arch Doc Cheat Sheet</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../Multifactor_Authentication_Cheat_Sheet/">Multifactor Authentication Cheat Sheet</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../Nodejs_security_cheat_sheet/">Nodejs security cheat sheet</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../OS_Command_Injection_Defense_Cheat_Sheet/">OS Command Injection Defense Cheat Sheet</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../PHP_Configuration_Cheat_Sheet/">PHP Configuration Cheat Sheet</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../Password_Storage_Cheat_Sheet/">Password Storage Cheat Sheet</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../Pinning_Cheat_Sheet/">Pinning Cheat Sheet</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../Query_Parameterization_Cheat_Sheet/">Query Parameterization Cheat Sheet</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../REST_Assessment_Cheat_Sheet/">REST Assessment Cheat Sheet</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../REST_Security_Cheat_Sheet/">REST Security Cheat Sheet</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../Ruby_on_Rails_Cheatsheet/">Ruby on Rails Cheatsheet</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../SAML_Security_Cheat_Sheet/">SAML Security Cheat Sheet</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../SQL_Injection_Prevention_Cheat_Sheet/">SQL Injection Prevention Cheat Sheet</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../Securing_Cascading_Style_Sheets_Cheat_Sheet/">Securing Cascading Style Sheets Cheat Sheet</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../Server_Side_Request_Forgery_Prevention_Cheat_Sheet/">Server Side Request Forgery Prevention Cheat Sheet</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../Session_Management_Cheat_Sheet/">Session Management Cheat Sheet</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../TLS_Cipher_String_Cheat_Sheet/">TLS Cipher String Cheat Sheet</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../Third_Party_Javascript_Management_Cheat_Sheet/">Third Party Javascript Management Cheat Sheet</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../Threat_Modeling_Cheat_Sheet/">Threat Modeling Cheat Sheet</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../Transaction_Authorization_Cheat_Sheet/">Transaction Authorization Cheat Sheet</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../Transport_Layer_Protection_Cheat_Sheet/">Transport Layer Protection Cheat Sheet</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../Unvalidated_Redirects_and_Forwards_Cheat_Sheet/">Unvalidated Redirects and Forwards Cheat Sheet</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../User_Privacy_Protection_Cheat_Sheet/">User Privacy Protection Cheat Sheet</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../Virtual_Patching_Cheat_Sheet/">Virtual Patching Cheat Sheet</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../Vulnerability_Disclosure_Cheat_Sheet/">Vulnerability Disclosure Cheat Sheet</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../Vulnerable_Dependency_Management_Cheat_Sheet/">Vulnerable Dependency Management Cheat Sheet</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../Web_Service_Security_Cheat_Sheet/">Web Service Security Cheat Sheet</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../XML_External_Entity_Prevention_Cheat_Sheet/">XML External Entity Prevention Cheat Sheet</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../XML_Security_Cheat_Sheet/">XML Security Cheat Sheet</a>
                    </li>
                </ul>
      </div>
    </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
        <a href="../..">OWASP Cheat Sheet Series</a>
      </nav>

      
      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="../..">Docs</a> &raquo;</li>
    
      
        
          <li>Cheatsheets &raquo;</li>
        
      
    
    <li>JSON Web Token Cheat Sheet for Java</li>
    <li class="wy-breadcrumbs-aside">
      
    </li>
  </ul>
  
  <hr/>
</div>
          <div role="main">
            <div class="section">
              
                <h1 id="introduction">Introduction<a class="headerlink" href="#introduction" title="Permanent link">&para;</a></h1>
<p>Many applications use <strong>JSON Web Tokens</strong> (JWT) to allow the client to indicate its identity for further exchange after authentication.</p>
<p>From <a href="https://jwt.io/introduction">JWT.IO</a>:</p>
<blockquote>
<p>JSON Web Token (JWT) is an open standard (RFC 7519) that defines a compact and self-contained way for securely transmitting information between parties as a JSON object. This information can be verified and trusted because it is digitally signed. JWTs can be signed using a secret (with the HMAC algorithm) or a public/private key pair using RSA.</p>
</blockquote>
<p>JSON Web Token is used to carry information related to the identity and characteristics (claims) of a client. This information is signed by the server in order for it to detect whether it was tampered with after sending it to the client. This will prevent an attacker from changing the identity or any characteristics (for example, changing the role from simple user to admin or change the client login).</p>
<p>This token is created during authentication (is provided in case of successful authentication) and is verified by the server before any processing. It is used by an application to allow a client to present a token representing the user's "identity card" to the server and allow the server to verify the validity and integrity of the token in a secure way, all of this in a stateless and portable approach (portable in the way that client and server technologies can be different including also the transport channel even if HTTP is the most often used).</p>
<h1 id="token-structure">Token Structure<a class="headerlink" href="#token-structure" title="Permanent link">&para;</a></h1>
<p>Token structure example taken from <a href="https://jwt.io/#debugger">JWT.IO</a>:</p>
<p><code>[Base64(HEADER)].[Base64(PAYLOAD)].[Base64(SIGNATURE)]</code></p>
<pre><code class="text">eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.
eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiYWRtaW4iOnRydWV9.
TJVA95OrM7E2cBab30RMHrHDcEfxjoYZgeFONFh7HgQ
</code></pre>

<p>Chunk 1: <strong>Header</strong></p>
<pre><code class="json">{
  &quot;alg&quot;: &quot;HS256&quot;,
  &quot;typ&quot;: &quot;JWT&quot;
}
</code></pre>

<p>Chunk 2: <strong>Payload</strong></p>
<pre><code class="json">{
  &quot;sub&quot;: &quot;1234567890&quot;,
  &quot;name&quot;: &quot;John Doe&quot;,
  &quot;admin&quot;: true
}
</code></pre>

<p>Chunk 3: <strong>Signature</strong></p>
<pre><code class="javascript">HMACSHA256( base64UrlEncode(header) + &quot;.&quot; + base64UrlEncode(payload), KEY )
</code></pre>

<h1 id="objective">Objective<a class="headerlink" href="#objective" title="Permanent link">&para;</a></h1>
<p>This cheatsheet provides tips to prevent common security issues when using JSON Web Tokens (JWT) with Java.</p>
<p>The tips presented in this article are part of a Java project that was created to show the correct way to handle creation and validation of JSON Web Tokens. </p>
<p>You can find the Java project <a href="https://github.com/righettod/poc-jwt">here</a>, it uses the official <a href="https://jwt.io/#libraries">JWT library</a>.</p>
<p>In the rest of the article, the term <strong>token</strong> refers to the <strong>JSON Web Tokens</strong> (JWT).</p>
<h1 id="consideration-about-using-jwt">Consideration about Using JWT<a class="headerlink" href="#consideration-about-using-jwt" title="Permanent link">&para;</a></h1>
<p>Even if a JWT token is "easy" to use and allow to expose services (mostly REST style) in a stateless way, it's not the solution that fits for all applications because it comes with some caveats, like for example the question of the storage of the token (tackled in this cheatsheet) and others...</p>
<p>If your application does not need to be fully stateless, you can consider using traditional session system provided by all web frameworks and follow the advice from the dedicated <a href="../Session_Management_Cheat_Sheet/">session management cheat sheet</a>. However, for stateless applications, when well implemented, it's a good candidate.</p>
<h1 id="issues">Issues<a class="headerlink" href="#issues" title="Permanent link">&para;</a></h1>
<h2 id="none-hashing-algorithm">None Hashing Algorithm<a class="headerlink" href="#none-hashing-algorithm" title="Permanent link">&para;</a></h2>
<h3 id="symptom">Symptom<a class="headerlink" href="#symptom" title="Permanent link">&para;</a></h3>
<p>This attack, described <a href="https://auth0.com/blog/critical-vulnerabilities-in-json-web-token-libraries/">here</a> occurs when an attacker alters the token and changes the hashing algorithm to indicate, through, the <em>none</em> keyword, that the integrity of the token has already been verified. As explained in the link above <em>some libraries treated tokens signed with the none algorithm as a valid token with a verified signature</em>, so an attacker can alter the token claims and token will be trusted by the application.</p>
<h3 id="how-to-prevent">How to Prevent<a class="headerlink" href="#how-to-prevent" title="Permanent link">&para;</a></h3>
<p>First, use a JWT library that is not exposed to this vulnerability.</p>
<p>Last, during token validation, explicitly request that the expected algorithm was used.</p>
<h3 id="implementation-example">Implementation Example<a class="headerlink" href="#implementation-example" title="Permanent link">&para;</a></h3>
<pre><code class="java">// HMAC key - Block serialization and storage as String in JVM memory
private transient byte[] keyHMAC = ...;

...

//Create a verification context for the token requesting 
//explicitly the use of the HMAC-256 hashing algorithm
JWTVerifier verifier = JWT.require(Algorithm.HMAC256(keyHMAC)).build();

//Verify the token, if the verification fail then a exception is throwed
DecodedJWT decodedToken = verifier.verify(token);
</code></pre>

<h2 id="token-sidejacking">Token Sidejacking<a class="headerlink" href="#token-sidejacking" title="Permanent link">&para;</a></h2>
<h3 id="symptom_1">Symptom<a class="headerlink" href="#symptom_1" title="Permanent link">&para;</a></h3>
<p>This attack occurs when a token has been intercepted/stolen by an attacker and they use it to gain access to the system using targeted user identity.</p>
<h3 id="how-to-prevent_1">How to Prevent<a class="headerlink" href="#how-to-prevent_1" title="Permanent link">&para;</a></h3>
<p>A way to prevent it is to add a "user context" in the token. A user context will be composed of the following information:</p>
<ul>
<li>A random string that will be generated during the authentication phase. It will be sent to the client as an hardened cookie (flags: <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Cookies#Secure_and_HttpOnly_cookies">HttpOnly + Secure</a> + <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Cookies#SameSite_cookies">SameSite</a> + <a href="https://googlechrome.github.io/samples/cookie-prefixes/">cookie prefixes</a>).</li>
<li>A SHA256 hash of the random string will be stored in the token (instead of the raw value) in order to prevent any XSS issues allowing the attacker to read the random string value and setting the expected cookie.</li>
</ul>
<p>IP addresses should not be used because there are some legitimate situations in which the IP address can change during the same session. For example, when an user accesses an application through their mobile device and the mobile operator changes during the exchange, then the IP address may (often) change. Moreover, using the IP address can potentially cause issues with <a href="http://www.eugdpr.org/">European GDPR</a> compliancy.</p>
<p>During token validation, if the received token does not contain the right context (for example, if it has been replayed), then it must be rejected.</p>
<h3 id="implementation-example_1">Implementation example<a class="headerlink" href="#implementation-example_1" title="Permanent link">&para;</a></h3>
<p>Code to create the token after successful authentication.</p>
<pre><code class="java">// HMAC key - Block serialization and storage as String in JVM memory
private transient byte[] keyHMAC = ...;
// Random data generator
private SecureRandom secureRandom = new SecureRandom();

...

//Generate a random string that will constitute the fingerprint for this user
byte[] randomFgp = new byte[50];
secureRandom.nextBytes(randomFgp);
String userFingerprint = DatatypeConverter.printHexBinary(randomFgp);

//Add the fingerprint in a hardened cookie - Add cookie manually because 
//SameSite attribute is not supported by javax.servlet.http.Cookie class
String fingerprintCookie = &quot;__Secure-Fgp=&quot; + userFingerprint 
                           + &quot;; SameSite=Strict; HttpOnly; Secure&quot;;
response.addHeader(&quot;Set-Cookie&quot;, fingerprintCookie);

//Compute a SHA256 hash of the fingerprint in order to store the 
//fingerprint hash (instead of the raw value) in the token
//to prevent an XSS to be able to read the fingerprint and 
//set the expected cookie itself
MessageDigest digest = MessageDigest.getInstance(&quot;SHA-256&quot;);
byte[] userFingerprintDigest = digest.digest(userFingerprint.getBytes(&quot;utf-8&quot;));
String userFingerprintHash = DatatypeConverter.printHexBinary(userFingerprintDigest);

//Create the token with a validity of 15 minutes and client context (fingerprint) information
Calendar c = Calendar.getInstance();
Date now = c.getTime();
c.add(Calendar.MINUTE, 15);
Date expirationDate = c.getTime();
Map&lt;String, Object&gt; headerClaims = new HashMap&lt;&gt;();
headerClaims.put(&quot;typ&quot;, &quot;JWT&quot;);
String token = JWT.create().withSubject(login)
   .withExpiresAt(expirationDate)
   .withIssuer(this.issuerID)
   .withIssuedAt(now)
   .withNotBefore(now)
   .withClaim(&quot;userFingerprint&quot;, userFingerprintHash)
   .withHeader(headerClaims)
   .sign(Algorithm.HMAC256(this.keyHMAC));
</code></pre>

<p>Code to validate the token.</p>
<pre><code class="java">// HMAC key - Block serialization and storage as String in JVM memory
private transient byte[] keyHMAC = ...;

...

//Retrieve the user fingerprint from the dedicated cookie
String userFingerprint = null;
if (request.getCookies() != null &amp;&amp; request.getCookies().length &gt; 0) {
 List&lt;Cookie&gt; cookies = Arrays.stream(request.getCookies()).collect(Collectors.toList());
 Optional&lt;Cookie&gt; cookie = cookies.stream().filter(c -&gt; &quot;__Secure-Fgp&quot;
                                            .equals(c.getName())).findFirst();
 if (cookie.isPresent()) {
   userFingerprint = cookie.get().getValue();
 }
}

//Compute a SHA256 hash of the received fingerprint in cookie in order to compare 
//it to the fingerprint hash stored in the token
MessageDigest digest = MessageDigest.getInstance(&quot;SHA-256&quot;);
byte[] userFingerprintDigest = digest.digest(userFingerprint.getBytes(&quot;utf-8&quot;));
String userFingerprintHash = DatatypeConverter.printHexBinary(userFingerprintDigest);

//Create a verification context for the token
JWTVerifier verifier = JWT.require(Algorithm.HMAC256(keyHMAC))
                              .withIssuer(issuerID)
                              .withClaim(&quot;userFingerprint&quot;, userFingerprintHash)
                              .build();

//Verify the token, if the verification fail then an exception is thrown
DecodedJWT decodedToken = verifier.verify(token);
</code></pre>

<h2 id="no-built-in-token-revocation-by-the-user">No Built-In Token Revocation by the User<a class="headerlink" href="#no-built-in-token-revocation-by-the-user" title="Permanent link">&para;</a></h2>
<h3 id="symptom_2">Symptom<a class="headerlink" href="#symptom_2" title="Permanent link">&para;</a></h3>
<p>This problem is inherent to JWT because a token only becomes invalid when it expires. The user has no built-in feature to explicitly revoke the validity of a token. This means that if it is stolen, a user cannot revoke the token itself thereby blocking the attacker.</p>
<h3 id="how-to-prevent_2">How to Prevent<a class="headerlink" href="#how-to-prevent_2" title="Permanent link">&para;</a></h3>
<p>A way to protect against this is to implement a token blacklist that will be used to mimic the "logout" feature that exists with traditional session management system.</p>
<p>The blacklist will keep a digest (SHA-256 encoded in HEX) of the token with a revocation date. This entry must endure at least until the expiration of the token.</p>
<p>When the user wants to "logout" then it call a dedicated service that will add the provided user token to the blacklist resulting in an immediate invalidation of the token for further usage in the application.</p>
<h3 id="implementation-example_2">Implementation Example<a class="headerlink" href="#implementation-example_2" title="Permanent link">&para;</a></h3>
<h4 id="blacklist-storage">Blacklist Storage<a class="headerlink" href="#blacklist-storage" title="Permanent link">&para;</a></h4>
<p>A database table with the following structure will be used as the central blacklist storage.</p>
<pre><code class="sql">create table if not exists revoked_token(jwt_token_digest varchar(255) primary key, 
revocation_date timestamp default now());
</code></pre>

<h4 id="token-revocation-management">Token Revocation Management<a class="headerlink" href="#token-revocation-management" title="Permanent link">&para;</a></h4>
<p>Code in charge of adding a token to the blacklist and checking if a token is revoked.</p>
<pre><code class="java">/**
* Handle the revocation of the token (logout).
* Use a DB in order to allow multiple instances to check for revoked token 
* and allow cleanup at centralized DB level.
*/
public class TokenRevoker {

 /** DB Connection */
 @Resource(&quot;jdbc/storeDS&quot;)
 private DataSource storeDS;

 /**
  * Verify if a digest encoded in HEX of the ciphered token is present 
  * in the revocation table
  *
  * @param jwtInHex Token encoded in HEX
  * @return Presence flag
  * @throws Exception If any issue occur during communication with DB
  */
 public boolean isTokenRevoked(String jwtInHex) throws Exception {
     boolean tokenIsPresent = false;
     if (jwtInHex != null &amp;&amp; !jwtInHex.trim().isEmpty()) {
         //Decode the ciphered token
         byte[] cipheredToken = DatatypeConverter.parseHexBinary(jwtInHex);

         //Compute a SHA256 of the ciphered token
         MessageDigest digest = MessageDigest.getInstance(&quot;SHA-256&quot;);
         byte[] cipheredTokenDigest = digest.digest(cipheredToken);
         String jwtTokenDigestInHex = DatatypeConverter.printHexBinary(cipheredTokenDigest);

         //Search token digest in HEX in DB
         try (Connection con = this.storeDS.getConnection()) {
             String query = &quot;select jwt_token_digest from revoked_token where jwt_token_digest = ?&quot;;
             try (PreparedStatement pStatement = con.prepareStatement(query)) {
                 pStatement.setString(1, jwtTokenDigestInHex);
                 try (ResultSet rSet = pStatement.executeQuery()) {
                     tokenIsPresent = rSet.next();
                 }
             }
         }
     }

     return tokenIsPresent;
 }


 /**
  * Add a digest encoded in HEX of the ciphered token to the revocation token table
  *
  * @param jwtInHex Token encoded in HEX
  * @throws Exception If any issue occur during communication with DB
  */
 public void revokeToken(String jwtInHex) throws Exception {
     if (jwtInHex != null &amp;&amp; !jwtInHex.trim().isEmpty()) {
         //Decode the ciphered token
         byte[] cipheredToken = DatatypeConverter.parseHexBinary(jwtInHex);

         //Compute a SHA256 of the ciphered token
         MessageDigest digest = MessageDigest.getInstance(&quot;SHA-256&quot;);
         byte[] cipheredTokenDigest = digest.digest(cipheredToken);
         String jwtTokenDigestInHex = DatatypeConverter.printHexBinary(cipheredTokenDigest);

         //Check if the token digest in HEX is already in the DB and add it if it is absent
         if (!this.isTokenRevoked(jwtInHex)) {
             try (Connection con = this.storeDS.getConnection()) {
                 String query = &quot;insert into revoked_token(jwt_token_digest) values(?)&quot;;
                 int insertedRecordCount;
                 try (PreparedStatement pStatement = con.prepareStatement(query)) {
                     pStatement.setString(1, jwtTokenDigestInHex);
                     insertedRecordCount = pStatement.executeUpdate();
                 }
                 if (insertedRecordCount != 1) {
                     throw new IllegalStateException(&quot;Number of inserted record is invalid,&quot; +
                     &quot; 1 expected but is &quot; + insertedRecordCount);
                 }
             }
         }

     }
 }
</code></pre>

<h2 id="token-information-disclosure">Token Information Disclosure<a class="headerlink" href="#token-information-disclosure" title="Permanent link">&para;</a></h2>
<h3 id="symptom_3">Symptom<a class="headerlink" href="#symptom_3" title="Permanent link">&para;</a></h3>
<p>This attack occurs when an attacker has access to a token (or a set of tokens) and extracts information stored in it (the contents of JWT tokens are base64 encoded, but is not encrypted by default) in order to obtain information about the system. Information can be for example the security roles, login format...</p>
<h3 id="how-to-prevent_3">How to Prevent<a class="headerlink" href="#how-to-prevent_3" title="Permanent link">&para;</a></h3>
<p>A way to protect against this attack is to cipher the token using, for example, a symmetric algorithm.</p>
<p>It's also important to protect the ciphered data against attack like <a href="https://owasp.org/www-project-web-security-testing-guide/stable/4-Web_Application_Security_Testing/09-Testing_for_Weak_Cryptography/02-Testing_for_Padding_Oracle.html">Padding Oracle</a> or any other attack using cryptanalysis.</p>
<p>In order to achieve all these goals, the <em>AES-<a href="https://en.wikipedia.org/wiki/Galois/Counter_Mode">GCM</a></em> algorithm is used which provides <em>Authenticated Encryption with Associated Data</em>.</p>
<p>More details from <a href="https://github.com/google/tink/blob/master/docs/PRIMITIVES.md#deterministic-authenticated-encryption-with-associated-data">here</a>:</p>
<pre><code class="text">AEAD primitive (Authenticated Encryption with Associated Data) provides functionality of symmetric 
authenticated encryption. 

Implementations of this primitive are secure against adaptive chosen ciphertext attacks. 

When encrypting a plaintext one can optionally provide associated data that should be authenticated 
but not encrypted. 

That is, the encryption with associated data ensures authenticity (ie. who the sender is) and 
integrity (ie. data has not been tampered with) of that data, but not its secrecy.

See RFC5116: https://tools.ietf.org/html/rfc5116
</code></pre>

<p><strong>Note:</strong></p>
<p>Here ciphering is added mainly to hide internal information but it's very important to remember that the first protection against tampering of the JWT token is the signature. So, the token signature and its verification must be always in place.</p>
<h3 id="implementation-example_3">Implementation Example<a class="headerlink" href="#implementation-example_3" title="Permanent link">&para;</a></h3>
<h4 id="token-ciphering">Token Ciphering<a class="headerlink" href="#token-ciphering" title="Permanent link">&para;</a></h4>
<p>Code in charge of managing the ciphering. <a href="https://github.com/google/tink">Google Tink</a> dedicated crypto library is used to handle ciphering operations in order to use built-in best practices provided by this library.</p>
<pre><code class="java">/**
 * Handle ciphering and deciphering of the token using AES-GCM.
 *
 * @see &quot;https://github.com/google/tink/blob/master/docs/JAVA-HOWTO.md&quot;
 */
public class TokenCipher {

    /**
     * Constructor - Register AEAD configuration
     *
     * @throws Exception If any issue occur during AEAD configuration registration
     */
    public TokenCipher() throws Exception {
        AeadConfig.register();
    }

    /**
     * Cipher a JWT
     *
     * @param jwt          Token to cipher
     * @param keysetHandle Pointer to the keyset handle
     * @return The ciphered version of the token encoded in HEX
     * @throws Exception If any issue occur during token ciphering operation
     */
    public String cipherToken(String jwt, KeysetHandle keysetHandle) throws Exception {
        //Verify parameters
        if (jwt == null || jwt.isEmpty() || keysetHandle == null) {
            throw new IllegalArgumentException(&quot;Both parameters must be specified!&quot;);
        }

        //Get the primitive
        Aead aead = AeadFactory.getPrimitive(keysetHandle);

        //Cipher the token
        byte[] cipheredToken = aead.encrypt(jwt.getBytes(), null);

        return DatatypeConverter.printHexBinary(cipheredToken);
    }

    /**
     * Decipher a JWT
     *
     * @param jwtInHex     Token to decipher encoded in HEX
     * @param keysetHandle Pointer to the keyset handle
     * @return The token in clear text
     * @throws Exception If any issue occur during token deciphering operation
     */
    public String decipherToken(String jwtInHex, KeysetHandle keysetHandle) throws Exception {
        //Verify parameters
        if (jwtInHex == null || jwtInHex.isEmpty() || keysetHandle == null) {
            throw new IllegalArgumentException(&quot;Both parameters must be specified !&quot;);
        }

        //Decode the ciphered token
        byte[] cipheredToken = DatatypeConverter.parseHexBinary(jwtInHex);

        //Get the primitive
        Aead aead = AeadFactory.getPrimitive(keysetHandle);

        //Decipher the token
        byte[] decipheredToken = aead.decrypt(cipheredToken, null);

        return new String(decipheredToken);
    }
}
</code></pre>

<h4 id="creation-validation-of-the-token">Creation / Validation of the Token<a class="headerlink" href="#creation-validation-of-the-token" title="Permanent link">&para;</a></h4>
<p>Use the token ciphering handler during the creation and the validation of the token.</p>
<p>Load keys (ciphering key was generated and stored using <a href="https://github.com/google/tink/blob/master/docs/JAVA-HOWTO.md#generating-new-keysets">Google Tink</a>) and setup cipher.</p>
<pre><code class="java">//Load keys from configuration text/json files in order to avoid to storing keys as a String in JVM memory
private transient byte[] keyHMAC = Files.readAllBytes(Paths.get(&quot;src&quot;, &quot;main&quot;, &quot;conf&quot;, &quot;key-hmac.txt&quot;));
private transient KeysetHandle keyCiphering = CleartextKeysetHandle.read(JsonKeysetReader.withFile(
Paths.get(&quot;src&quot;, &quot;main&quot;, &quot;conf&quot;, &quot;key-ciphering.json&quot;).toFile()));

...

//Init token ciphering handler
TokenCipher tokenCipher = new TokenCipher();
</code></pre>

<p>Token creation.</p>
<pre><code class="java">//Generate the JWT token using the JWT API...
//Cipher the token (String JSON representation)
String cipheredToken = tokenCipher.cipherToken(token, this.keyCiphering);
//Send the ciphered token encoded in HEX to the client in HTTP response...
</code></pre>

<p>Token validation.</p>
<pre><code class="java">//Retrieve the ciphered token encoded in HEX from the HTTP request...
//Decipher the token
String token = tokenCipher.decipherToken(cipheredToken, this.keyCiphering);
//Verify the token using the JWT API...
//Verify access...
</code></pre>

<h2 id="token-storage-on-client-side">Token Storage on Client Side<a class="headerlink" href="#token-storage-on-client-side" title="Permanent link">&para;</a></h2>
<h3 id="symptom_4">Symptom<a class="headerlink" href="#symptom_4" title="Permanent link">&para;</a></h3>
<p>This occurs when an application stores the token in a manner exhibiting the following behavior:</p>
<ul>
<li>Automatically sent by the browser (<em>Cookie</em> storage).</li>
<li>Retrieved even if the browser is restarted (Use of browser <em>localStorage</em> container).</li>
<li>Retrieved in case of <a href="../Cross_Site_Scripting_Prevention_Cheat_Sheet/">XSS</a> issue (Cookie accessible to JavaScript code or Token stored in browser local/session storage).</li>
</ul>
<h3 id="how-to-prevent_4">How to Prevent<a class="headerlink" href="#how-to-prevent_4" title="Permanent link">&para;</a></h3>
<ol>
<li>Store the token using the browser <em>sessionStorage</em> container.</li>
<li>Add it as a <em>Bearer</em> HTTP <code>Authentication</code> header with JavaScript when calling services.</li>
<li>Add <a href="./#token-sidejacking">fingerprint</a> information to the token.</li>
</ol>
<p>By storing the token in browser <em>sessionStorage</em> container it exposes the token to being stolen through a XSS attack. However, fingerprints added to the token prevent reuse of the stolen token by the attacker on their machine. To close a maximum of exploitation surfaces for an attacker, add a browser <a href="https://cheatsheetseries.owasp.org/cheatsheets/Content_Security_Policy_Cheat_Sheet.html">Content Security Policy</a> to harden the execution context.</p>
<p><em>Note:</em></p>
<ul>
<li>The remaining case is when an attacker uses the user's browsing context as a proxy to use the target application through the legitimate user but the Content Security Policy can prevent communication with non expected domains.</li>
<li>It's also possible to implement the authentication service in a way that the token is issued within a hardened cookie, but in this case, protection against a <a href="../Cross-Site_Request_Forgery_Prevention_Cheat_Sheet/">Cross-Site Request Forgery</a> attack must be implemented.</li>
</ul>
<h3 id="implementation-example_4">Implementation Example<a class="headerlink" href="#implementation-example_4" title="Permanent link">&para;</a></h3>
<p>JavaScript code to store the token after authentication.</p>
<pre><code class="javascript">/* Handle request for JWT token and local storage*/
function authenticate() {
    const login = $(&quot;#login&quot;).val();
    const postData = &quot;login=&quot; + encodeURIComponent(login) + &quot;&amp;password=test&quot;;

    $.post(&quot;/services/authenticate&quot;, postData, function (data) {
        if (data.status == &quot;Authentication successful!&quot;) {
            ...
            sessionStorage.setItem(&quot;token&quot;, data.token);
        }
        else {
            ...
            sessionStorage.removeItem(&quot;token&quot;);
        }
    })
    .fail(function (jqXHR, textStatus, error) {
        ...
        sessionStorage.removeItem(&quot;token&quot;);
    });
}
</code></pre>

<p>JavaScript code to add the token as a <em>Bearer</em> HTTP Authentication header when calling a service, for example a service to validate token here.</p>
<pre><code class="javascript">/* Handle request for JWT token validation */
function validateToken() {
    var token = sessionStorage.getItem(&quot;token&quot;);

    if (token == undefined || token == &quot;&quot;) {
        $(&quot;#infoZone&quot;).removeClass();
        $(&quot;#infoZone&quot;).addClass(&quot;alert alert-warning&quot;);
        $(&quot;#infoZone&quot;).text(&quot;Obtain a JWT token first :)&quot;);
        return;
    }

    $.ajax({
        url: &quot;/services/validate&quot;,
        type: &quot;POST&quot;,
        beforeSend: function (xhr) {
            xhr.setRequestHeader(&quot;Authorization&quot;, &quot;bearer &quot; + token);
        },
        success: function (data) {
            ...
        },
        error: function (jqXHR, textStatus, error) {
            ...
        },
    });
}
</code></pre>

<h2 id="weak-token-secret">Weak Token Secret<a class="headerlink" href="#weak-token-secret" title="Permanent link">&para;</a></h2>
<h3 id="symptom_5">Symptom<a class="headerlink" href="#symptom_5" title="Permanent link">&para;</a></h3>
<p>When the token is protected using an HMAC based algorithm, the security of the token is entirely dependent on the strength of the secret used with the HMAC. If an attacker can obtain a valid JWT, they can then carry out an offline attack and attempt to crack the secret using tools such as <a href="https://github.com/magnumripper/JohnTheRipper">John the Ripper</a> or <a href="https://github.com/hashcat/hashcat">Hashcat</a>.</p>
<p>If they are successful, they would then be able to modify the token and re-sign it with the key they had obtained. This could let them escalate their privileges, compromise other users' accounts, or perform other actions depending on the contents of the JWT.</p>
<p>There are a number of <a href="https://www.notsosecure.com/crafting-way-json-web-tokens/">guides</a> that document this process in greater detail.</p>
<h3 id="how-to-prevent_5">How to Prevent<a class="headerlink" href="#how-to-prevent_5" title="Permanent link">&para;</a></h3>
<p>The simplest way to prevent this attack is to ensure that the secret used to sign the JWTs is strong and unique, in order to make it harder for an attacker to crack. As this secret would never need to be typed by a human, it should be at least 64 characters, and generated using a <a href="../Cryptographic_Storage_Cheat_Sheet/#secure-random-number-generation">secure source of randomness</a>.</p>
<p>Alternatively, consider the use of tokens that are signed with RSA rather than using an HMAC and secret key.</p>
<h3 id="further-reading">Further Reading<a class="headerlink" href="#further-reading" title="Permanent link">&para;</a></h3>
<ul>
<li><a href="https://github.com/ticarpi/jwt_tool/wiki">{JWT}.{Attack}.Playbook</a> - A project documents the known attacks and potential security vulnerabilities and misconfigurations of JSON Web Tokens.</li>
<li><a href="https://datatracker.ietf.org/doc/draft-ietf-oauth-jwt-bcp/">JWT Best Practices Internet Draft</a></li>
</ul>
              
            </div>
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="../Key_Management_Cheat_Sheet/" class="btn btn-neutral float-right" title="Key Management Cheat Sheet">Next <span class="icon icon-circle-arrow-right"></span></a>
      
      
        <a href="../JAAS_Cheat_Sheet/" class="btn btn-neutral" title="JAAS Cheat Sheet"><span class="icon icon-circle-arrow-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <!-- Copyright etc -->
    
  </div>

  Built with <a href="https://www.mkdocs.org/">MkDocs</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>.
</footer>
      
        </div>
      </div>

    </section>

  </div>

  <div class="rst-versions" role="note" aria-label="versions">
    <span class="rst-current-version" data-toggle="rst-current-version">
      
      
        <span><a href="../JAAS_Cheat_Sheet/" style="color: #fcfcfc;">&laquo; Previous</a></span>
      
      
        <span style="margin-left: 15px"><a href="../Key_Management_Cheat_Sheet/" style="color: #fcfcfc">Next &raquo;</a></span>
      
    </span>
</div>
    <script>var base_url = '../..';</script>
    <script src="../../js/theme.js" defer></script>
      <script src="../../search/main.js" defer></script>
    <script defer>
        window.onload = function () {
            SphinxRtdTheme.Navigation.enable(false);
        };
    </script>

</body>
</html>
